package com.ftn.sbnz.gcm.rules

import com.ftn.sbnz.gcm.model.models.Trend;
import com.ftn.sbnz.gcm.model.models.GlucoseMeasurement;
import com.ftn.sbnz.gcm.model.models.GlucoseTrendConfig;
import com.ftn.sbnz.gcm.model.models.InsulinEvent;
import com.ftn.sbnz.gcm.model.models.FoodConstraint;
import com.ftn.sbnz.gcm.model.enums.TrendType;
import com.ftn.sbnz.gcm.model.enums.GlycemicIndexType;
import java.util.List;
import com.ftn.sbnz.gcm.model.models.Suggestion;
import com.ftn.sbnz.gcm.model.models.Food;

global org.kie.api.runtime.Channel trend; // emits Trend
global org.kie.api.runtime.Channel sugg;  // emits Suggestion

global GlucoseTrendConfig config;
global org.kie.api.time.SessionClock droolsClock;

// Utility function to calculate maximum absolute delta between consecutive glucose measurements
function double calculateMaxDelta(List samples) {
    double maxDelta = 0.0;
    for (int i = 0; i < samples.size() - 1; i++) {
        GlucoseMeasurement current = (GlucoseMeasurement) samples.get(i);
        GlucoseMeasurement next = (GlucoseMeasurement) samples.get(i + 1);
        double delta = Math.abs(next.getValue() - current.getValue());
        if (delta > maxDelta) {
            maxDelta = delta;
        }
    }
    return maxDelta;
}

// Utility function to calculate weighted delta combining recent and overall trend
function double getWeightedDelta(List samples) {
    if (samples == null || samples.size() < 2) return 0.0;

    double first = ((GlucoseMeasurement) samples.get(0)).getValue();
    double last = ((GlucoseMeasurement) samples.get(samples.size() - 1)).getValue();

    // Original net delta
    double netDelta = last - first;

    // Recent trend (last up to 3 measurements)
    int recentCount = Math.min(3, samples.size());
    double recentFirst = ((GlucoseMeasurement) samples.get(samples.size() - recentCount)).getValue();
    double recentDelta = last - recentFirst;

    // Weighted combination: 60% recent trend, 40% overall trend
    return 0.6 * recentDelta + 0.4 * netDelta;
}

declare TrendSignal
    netDelta : double
    maxDelta : double
end

declare CorrectionNeeded
    @role(event)
    @timestamp(timestamp)
    timestamp : long
end

rule "Build TrendSignal (weighted recent values)"
salience 10
when
    $samples : List( size >= 3 )
        from accumulate(
            $gm : GlucoseMeasurement() over window:time(16m),
            collectList($gm)
        )
    $weightedDelta : Double() from getWeightedDelta($samples)
    $maxDelta      : Double() from calculateMaxDelta($samples)
then
    insertLogical(new TrendSignal($weightedDelta, $maxDelta));
end


rule "Trend channel"
when
    $t : Trend()
then
    trend.send($t);
end

// 1) Raise a correction-needed flag if UP trend + high glucose + no insulin within 30m after that reading
rule "Corrective action for UP trend"
when
    Trend( direction == TrendType.UP )
    $gm: GlucoseMeasurement( value > 9.9 )
    not( GlucoseMeasurement( timestamp > $gm.timestamp ) )  // Only latest glucose
    not( InsulinEvent( at >= ($gm.getTimestamp() - 1800000) ) ) // 30min before glucose
    not( CorrectionNeeded() ) // avoid duplicates
then
    System.out.println("High glucose with UP trend and no recent insulin, suggesting correction." + $gm);
    CorrectionNeeded cn = new CorrectionNeeded();
    cn.setTimestamp( droolsClock.getCurrentTime() );
    sugg.send( new Suggestion("High glucose with UP trend detected, waiting for glucose to stabilize before suggesting correction...") );
    insert(cn);
end

rule "Suggest correction"
when
    CorrectionNeeded()
    $latest: GlucoseMeasurement()
    not( GlucoseMeasurement( timestamp > $latest.timestamp ) ) // only latest
    // glucose > 9.9 checked in previous rule
    eval( $latest.getValue() > 9.9 )
    not Trend( direction == TrendType.UP )
then
    // simple heuristic: ceil((glucose - 7)/2), floor at 0
    int units = (int) Math.max(0, Math.ceil( ($latest.getValue() - 7.0) / 2.0 ));
    String message = "Consider taking " + units + " units of insulin to correct high glucose. ";
    sugg.send( new Suggestion(message) );
end

// 3) Optional: explicit cleanup (usually not needed due to insertLogical above).
//    If you keep it, make sure both sides are events with timestamps.
rule "Remove correction need after insulin event (redundant if using insertLogical)"
salience -10
when
    $cn: CorrectionNeeded()
    InsulinEvent( this after[0s, *] $cn )
then
    retract($cn);
    sugg.send( new Suggestion("Insulin taken, keeping an eye on glucose...") );
end

rule "Remove correction need after glucose back to normal"
salience -10
when
    $cn: CorrectionNeeded()
    $latest: GlucoseMeasurement( value <= 9.9, timestamp > $cn.timestamp )
    not( GlucoseMeasurement( timestamp > $latest.timestamp ) )
then
    retract($cn);
    sugg.send( new Suggestion("Glucose back to normal, no correction needed.") );
end

rule "Suggest Food With Lower Glycemic Index"
when
    $foodConstraint: FoodConstraint( glycemicIndexType == GlycemicIndexType.LOW )
    $foods: List(size > 0) from accumulate(
        $f: Food(
            carbs >= $foodConstraint.minCarbs,
            carbs <= $foodConstraint.maxCarbs,
            fats <= $foodConstraint.maxFats,
            glycemicIndex < 55
        ),
        collectList($f)
    )
then
    Food first = (Food) $foods.get(0);
    String message = "Based on your recent glucose levels and activity, consider eating " + first;
    sugg.send( new Suggestion(message) );
    retract($foodConstraint);
end

rule "Suggest Food With Medium Glycemic Index"
when
    $foodConstraint: FoodConstraint( glycemicIndexType == GlycemicIndexType.MEDIUM )
    $foods: List(size > 0) from accumulate(
        $f: Food(
            carbs >= $foodConstraint.minCarbs,
            carbs <= $foodConstraint.maxCarbs,
            fats <= $foodConstraint.maxFats,
            glycemicIndex >= 55, glycemicIndex <= 69
        ),
        collectList($f)
    )
then
    Food first = (Food) $foods.get(0);
    String message = "Based on your recent glucose levels and activity, consider eating " + first;
    sugg.send( new Suggestion(message) );
    retract($foodConstraint);
end

rule "Suggest Food With High Glycemic Index"
when
    $foodConstraint: FoodConstraint( glycemicIndexType == GlycemicIndexType.HIGH )
    $foods: List() from accumulate(
        $f: Food(
            carbs >= $foodConstraint.minCarbs,
            carbs <= $foodConstraint.maxCarbs,
            fats <= $foodConstraint.maxFats,
            glycemicIndex >= 70
        ),
        collectList($f)
    )
then
    Food first = (Food) $foods.get(0);
    String message = "Based on your recent glucose levels and activity, consider eating " + first;
    sugg.send( new Suggestion(message) );
    retract($foodConstraint);
end