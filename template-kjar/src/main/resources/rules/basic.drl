package com.ftn.sbnz.gcm.rules

import com.ftn.sbnz.gcm.model.models.Trend;
import com.ftn.sbnz.gcm.model.models.GlucoseMeasurement;
import com.ftn.sbnz.gcm.model.models.GlucoseTrendConfig;
import com.ftn.sbnz.gcm.model.models.InsulinEvent;
import com.ftn.sbnz.gcm.model.enums.TrendType;
import java.util.List
import com.ftn.sbnz.gcm.model.models.Suggestion;

global org.kie.api.runtime.Channel trend; // emits Trend
global org.kie.api.runtime.Channel sugg;  // emits Suggestion

global GlucoseTrendConfig config;


declare TrendSignal
    netDelta : double
    maxDelta : double
end

declare CorrectionNeeded
    @role(event)
    @timestamp(timestamp)
    timestamp : long
end

rule "Build TrendSignal (weighted recent values)"
salience 10
when
    $samples : List(size >= 3) from accumulate(
        $gm: GlucoseMeasurement() over window:time(16m),
        collectList($gm)
    )
then
    double first = ((GlucoseMeasurement) $samples.get(0)).getValue();
    double last = ((GlucoseMeasurement) $samples.get($samples.size() - 1)).getValue();

    // Original net delta
    double netDelta = last - first;

    // Recent trend (last 2-3 measurements)
    int recentCount = Math.min(3, $samples.size());
    double recentFirst = ((GlucoseMeasurement) $samples.get($samples.size() - recentCount)).getValue();
    double recentDelta = last - recentFirst;

    // Weighted combination: 60% recent trend, 40% overall trend
    double weightedDelta = 0.6 * recentDelta + 0.4 * netDelta;

    // Calculate maxDelta as before...
    double maxDelta = 0.0;
    for (int i = 0; i < $samples.size() - 1; i++) {
        GlucoseMeasurement current = (GlucoseMeasurement) $samples.get(i);
        GlucoseMeasurement next = (GlucoseMeasurement) $samples.get(i + 1);
        double delta = Math.abs(next.getValue() - current.getValue());
        if (delta > maxDelta) maxDelta = delta;
    }

    insertLogical(new TrendSignal(weightedDelta, maxDelta));
end

rule "UNKNOWN trend"
when
    TrendSignal( Math.abs(netDelta) < config.stableNetDeltaThreshold, maxDelta > config.maxDeltaSpikeThreshold )
then
    insertLogical(new Trend(TrendType.UNKNOWN, 0));
end

// mutually exclusive classification
rule "UP fast" activation-group "trend-classify"
when
    TrendSignal( netDelta > config.strongUpThreshold )
then
    insertLogical(new Trend(TrendType.UP, 2));
end

rule "UP slow" activation-group "trend-classify"
when
    TrendSignal( netDelta > config.slightUpThreshold, netDelta <= config.strongUpThreshold )
then
    insertLogical(new Trend(TrendType.UP, 1));
end

rule "STABLE" activation-group "trend-classify"
    when TrendSignal( netDelta >= config.slightDownThreshold, netDelta <= config.slightUpThreshold )
then
    insertLogical(new Trend(TrendType.STABLE, 1));
end

rule "DOWN fast" activation-group "trend-classify"
when
    TrendSignal( netDelta < config.strongDownThreshold )
then
    insertLogical(new Trend(TrendType.DOWN, 2));
end

rule "DOWN slow" activation-group "trend-classify"
when
    TrendSignal( netDelta < config.slightDownThreshold && netDelta >= config.strongDownThreshold )
then
    insertLogical(new Trend(TrendType.DOWN, 1));
end

rule "Trend channel"
when
    $t : Trend()
then
    trend.send($t);
end

// 1) Raise a correction-needed flag if UP trend + high glucose + no insulin within 30m after that reading
rule "Corrective action for UP trend"
when
    Trend( direction == TrendType.UP )
    $gm: GlucoseMeasurement( value > 9.9 )
    not( InsulinEvent( this after[0s, 30m] $gm ) )
    not( CorrectionNeeded() ) // avoid duplicates
then
    System.out.println("High glucose with UP trend and no recent insulin, suggesting correction.");
    insert(new CorrectionNeeded(System.currentTimeMillis()));
end

rule "Suggest correction"
when
    CorrectionNeeded()
    $maxVal: Number() from accumulate(
      $g: GlucoseMeasurement() over window:time(30m),
      max( $g.getValue() )
    )
    Double( this > 9.9 ) from $maxVal.doubleValue()
    not Trend( direction == TrendType.UP )
then
    // simple heuristic: ceil((glucose - 7)/2), floor at 0
    int units = (int) Math.max(0, Math.ceil( ($maxVal.doubleValue() - 7.0) / 2.0 ));
    String message = "Consider taking " + units + " units of insulin to correct high glucose.";
    sugg.send( new Suggestion(message, units) );
end

// 3) Optional: explicit cleanup (usually not needed due to insertLogical above).
//    If you keep it, make sure both sides are events with timestamps.
rule "Remove correction need after insulin event (redundant if using insertLogical)"
salience -10
when
    $cn: CorrectionNeeded()
    InsulinEvent( this after[0s, *] $cn )
then
    retract($cn);
    System.out.println("Correction made, suggestion no longer needed.");
end

rule "Remove correction need after glucose back to normal"
salience -10
when
    $cn: CorrectionNeeded()
    $latest: GlucoseMeasurement( value <= 9.9, timestamp > $cn.timestamp )
    not( GlucoseMeasurement( timestamp > $latest.timestamp ) )
then
    retract($cn);
    System.out.println("Glucose back to normal, suggestion no longer needed.");
end